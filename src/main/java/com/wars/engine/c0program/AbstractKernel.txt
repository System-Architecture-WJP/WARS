typedef uint' ptrunsigned; // pointer unsigned integer type
typedef uint[32] u; // spr
typedef uint[8] v; // gpr
typedef struct {u GPR; v SPR} pcb; // gpr + spr
typedef pcb[3] PCBt; // for p user and + abstract kernel (gpr + spr)

typedef uint[4] PTAt; // page table entries array
typedef uint[3] PTOIt; // page table origin array for p user and abstract kernel

typedef struct {uint usr; uint px} auxrec; // for a physical page it stores user which held this page and respective virtual page
typedef auxrec[2] IPTt; // for every physical page, above


uint CP; // Current Process 0 - kernel, > 0 - user
bool ipf; // invalid page fault
PCBt PCB; // Process Control Block
PTAt PTA; // Page Table Address
PTOIt PTOI; // Page Table Origin

uint i; // interrupt mask
uint IL; // interrupt level
uint found; // interrupt found
uint EVA; // exception virtual address
uint EVPX; // exception virutal address page index
bool ptle; // page table length exception
bool psfull; // all physical pages are full
uint nextup; // next page index to swap in
IPTt ipt; //
int WOV; // write only variable for void functions

uint p;
uint PTASIZE;
uint nup;
uint PTLE;

uint K;

uint HDBASE;
uint UPBASE;
uint SMBASE;
uint SMUSERPAGE;
uint SMSIZE;




int readms(uint a){ //software read from hardwware memory

        int tmp;
        gpr(1) = a;
        asm( lw 2 1 0 );
        asm( sw 2 29 -4 );
        return tmp
};


void writems(uint x, uint a){ //software write to hardware memory

        gpr(1) = x;
        gpr(2) = a {1};
        asm( sw 1 2 0 )
};


void copyms(uint a, uint b, uint L){ //copies L words starting from a in MS to words from b

        gpr(1) = a;
        gpr(2) = b {1};
        gpr(3) = L {1, 2};

        asm( blez 3 7 ); // until L <= 0 {
        asm( lw 4 1 0 );
        asm( sw 4 2 0 ); // m(b) = m(a)
        asm( addi 1 1 4 ); // a += 4
        asm( addi 2 2 4 ); // b += 4
        asm( addi 3 3 -1 ); // L -= 1
        asm( blez 0 -6 ) // }
};


void readdisk(uint ppx, uint spx){ // ppx - MS page index where page is stored, spx - swap memory page index which is read

        int y;
        writems(spx, HDBASE+4u*K); // spa(d) = spx
        writems(1u, HDBASE+4u*K+4u); // issue read access

        y = 1;
        while y!=0 {
                y = readms(HDBASE+4u*K+4u) // polling
        };

        copyms(HDBASE, ppx*4u*K, K)
};


void writedisk(uint spx, uint ppx){ // spx - swap memory page index which is written, ppx - page index which is stored

        int y;
        copyms(ppx*4u*K, HDBASE, K);
        writems(spx, HDBASE+4u*K); // spa(d) = spx
        writems(2u, HDBASE+4u*K+4u); // issue write access

        y = 2;
        while y!=0 {
                y = readms(HDBASE+4u*K+4u) // polling
        }

};


void swapIn(){

        uint PPXIN; // pysical page index to swap in
        uint SPAIN; // swap page index to swap in
        uint PTEIIN; // pate table entry index to swap in

        PPXIN = UPBASE / (K*4u) + nextup;
        SPAIN = SMBASE + CP*SMUSERPAGE + EVPX;
        PTEIIN = PTOI[CP] + EVPX;
        readdisk(PPXIN, SPAIN); // read page from disk
        PTA[PTEIIN] = PPXIN*4u*K + 2u*K;

        ipt[nextup].usr = CP; // set user
        ipt[nextup].px = EVPX // set page index

};

void swapOut(){

        uint PPXOUT; // physical page index to swap out
        uint SPAOUT; // swap page index to swap out
        uint PTEIOUT; // page table entry index to swap out

        PPXOUT = UPBASE / 4u*K + nextup;
        SPAOUT = SMBASE + ipt[nextup].usr*SMUSERPAGE + ipt[nextup].px;
        PTEIOUT = PTOI[ipt[nextup].usr] + ipt[nextup].px;

        writedisk(SPAOUT, PPXOUT); // write page to disk
        PTA[PTEIOUT] = PTA[PTEIOUT]-2u*K

};

void ipfHandler(){

        if (!(bool)psfull) {swapIn()} else {swapOut(); swapIn()};

        nextup = nextup + 1u;
        if nextup==nup {nextup = 0u; psfull = true}
};

void scheduler(){

        if CP==p {CP = 1u} else {CP = CP+1u} // increment CP by 1
};


void runvm(){

        gpr(1) = PCB[CP].GPR[0]&; // save current user on scratch memory
        asm( macro: restore-user ); // save spr's for kernel, restore user_cp configuration

        asm( macro: save-user ); // save user_cp configuration, restore kernel

        IL = 0u;
        i = 1u;
        found = 0u;
        while found==0u {
                IL = IL+1u;
                i = 2u*i;
                gpr(1) = i;
                gpr(2) = PCB[CP].SPR[2] {1};
                asm( and 3 1 2 );
                found = gpr(3)
        };

        EVA = 0u;
        if IL==17u {EVA = PCB[CP].SPR[3]};
        if IL==20u {EVA = PCB[CP].SPR[4]};

        gpr(1) = EVA;
        asm( srl 1 1 12 );
        EVPX = gpr(1);

        ptle = (EVPX>=PCB[CP].SPR[6]);
        ipf = (IL==17u||IL==20u)&&!(bool)ptle;


        if (bool)ipf {ipfHandler(); gpr(1) = PCB[CP].GPR[0]&; asm( macro: restore-user )} // if there is ipf handle it, go back to user_cp
};

int main(){
        uint i;

        p = 2u;
        nup = 2u;
        K = 1024u;
        SMUSERPAGE = 1048576u;
        PTLE = 2u;
        SMSIZE = 268435456u;

        PTASIZE = p*PTLE;
        UPBASE = 20u*K;
        HDBASE = UPBASE + 4u*K*nup + K;
        SMBASE = SMSIZE-p*SMUSERPAGE;

        i = 1u;
        while i<PTASIZE+1u {
                PTA[i] = 0u;
                i = i + 1u
        };

        i = 1u;
        while i<p+1u {
                PTOI[i] = (i-1u)*2u;
                i = i + 1u
        };

        i = 1u;
        while i<p+1u {
                PCB[i].SPR[6] = 2u;
                i = i + 1u
        };

        i = 1u;
        while i<p+1u {
                gpr(1) = PTA[PTOI[i]]&;
                PCB[i].SPR[5] = gpr(1);
                i = i + 1u
        };

        psfull = false;
        nextup = 0u;

        gpr(1) = PCB[0].GPR[0]&; // init referernce on scratch memory
        asm( sw 1 0 4096 );
        while true {
                scheduler();
                runvm()
        };
        return 1
}~